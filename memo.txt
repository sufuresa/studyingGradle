<<< 11.Introduction to Groovy Clusures >>>

One of the biggest aspects of the groovy language that is used in gladle is that of closures.
                   物事の面
So I'll be spending some time looking at closures what they are and how they work and the various types of syntax they use.

So what are closure? (What) a kind of like lambda in Java 8 or code blocks in Smalltalk .
And they declare by using a pair of curly braces. (and) which we defined a closure we can actually assign it to a variable a bit like a value if you like.
                                    {}
                                    
                                    def echoIt = {}
                                    
                                    
So here I've got the accurate variable I'm assigning it to the definition of a closure.
Now to actually run a closure or evalueate it we use the parentheses or open and close brackets a bit like a method call.
                                                         丸括弧                        かぎ括弧[]
So here by including the open and close parentheses on the accurate variable telling groovy we actually want to invoke or evaluate that closure.
                                        丸括弧
                                        
                                        println echoIt()

And when we do, you see the result is null because basically we don't have any contents within our closure.
Now if we actually leave off the parentheses we can actually print out the actual toString method on the closure.
                   上記20行目の()を削除すると…
And as you see here it's quite a long meaningless name, but it shows that we're not actually evaluating the closure, we're actually calling the toString method on the closure itself.
You can think of closure as almost like an anonymous in a class in Java.
Okay so let's go ahead and actually put some code in our closure.
We can actually do the print line "Hello World" again.
Now you'll see that we're not actually returning a value here, and clusure are very much like methods they always return value of the last statement

                                    def echoIt = {
                                      println "Hello World"
                                    }

So here the last statement was print line and print line does not retuen a value.
So the default value that gets returned is null.
But we can also see the contents of our closure got evaluated,
and the "Hello World" was printed out to the console.
(上記の実行結果は、"Hello World" のあとnullが出力されている)

So so far we've seen that evaluating closure is very similar to that of methods.
                          ------------------
                          println echoIt …左記のようにechoItに対してprintlnしていることを"evaluating closure"といっている？

-- 2:17 ---

※上記のdef を Closure にしてもよい。

<<< 12. ...more about Closures >>>
Closures
	①As Method Parameters
	②Special Syntax
	③Code Block

①We are going to be concentrating on looking at passing clusures as parameters to our method.
　Who's going to examine the special type of syntax we need to do this when there's more than one parameter being passed to a method.
②And finally I'm going to look at a design pattern called code block and that's used quite frequently within gradle.

①Okay so let's start off by looking at how we can actually pass a closure to a method as a parameter.　…クロージャをメソッドパラメタとして渡す
　So as you can see I've created or defined a method here it's name is oneArgMethod and it accepts one parameter which is going to be the closure.
　So I'm going to keep the actual implementation of this method fairly straightforward.
　                                                              -----------------------
　                                                              簡単
　What I'm going to do is actually multipy the result of running the closure with 2.
  So I have to invoke the closure that gets passed in, and then the result that gets returned by that clusure gets multiplied by 2.
  And then I'm going to print out the result to the console,
  so calling the method itself is like calling any other method (readers) just use the method name known as the parameter which is the closure itself, we use the curly braces.
  Now you notice here I'm leaving off the parentheses that go with the method call because in groovy the parentheses are method call are actually optional.
  So here in basic running the method passing in the closure with various values passed in for now if just passed in 10 and you'll notice that those values get multiplied by 2
  because in our one argument method we actually invoke the closure and then we multiply the result by 2 and as that statement is the last thing in the method,
  the result automatically gets returned.　…実行結果を見る

// pass clusures as a parameter
def oneArgMethod(closure) {
	closure() * 2
}
println oneArgMethod {10}

  The syntax changes a little bit.
  When we have two arguments passed in as parameters to our method.
  So for example we pass in the closure but we also pass in the factor.
  So instead of hardcording 2 into our method we pass it in as a factor.
  
def oneArgMethod(factor, closure) {
	closure() * factor
}
println oneArgMethod(3,{10})

  Now when there's more than one argument passed into a method and one of those arguments is a closure,
  the closure is (or) the last argument to be passed in, 
  and there is an advantage to that.
  The advantage is we don't need to wrap the closure part of the argument with parentheses. 
  So as you can see here the parentheses brackets are optional.

println oneArgMethod 3,{10}

Now also to know the closures don't need to be one line of code,
you can have multiple lines of code within a closure so let's have a look at an example of that.

Okay so let's define a new variable "i" which is going to contain the result of our call to "oneArgMethod".
"oneArgMethod" method is going to take in our multiple line closure which is y=3 , and then y * 2, is that 6 ?

def i = oneArgMethod {
	def y = 3
	y * 2
}

"i" is equals to 12 because don't forget our closure gets passed into our method call.

That's assert that "i" equals 12.
Now (grading and) passing in multi line closure as parameters into method is a really popular pattern
or technique and it's used extensively(広く) in gradle.
This is called a "block" or a "code block".

In fact we don't need to look too far in the actual groovy API as well to find this technique being used quite often.
In fact if you look at the common usecases for collections, you will see multi line closures being used all the time.

So let's compare the two techniques.

This is a traditional way of doing things with a for loop as you're pretty much there in Java.
We're iterating over an array of numbers 1,2,3 and then "j" basally is each item in that array or collection, and then we print out.

for (int j in [1,2,3]) {
	print j
}

And groovy a little bit different.
We have our collection and that collection has a (methodologic(方法論) …多分違う) called each
and that method "each" accepts as an argument, a closure. 
And we pass that closure into the method "each" and once basically the code
gets evaluated each element from the collection gets passed into the closure.
So just to reiterate we call a closure once for each item passing the item to the closure as the argument.
Now as much more object oriented than the  standard follow.

[1,2,3].each {
	print it
}

<<< 13. What is Closure "Resolution"...? >>>

～導入部は省略～

In this example I have a class of Person and the Person has a name which is an instance variable.

class Person {
    String name = "Fred"
	Closure nameSayer = {
		println name
	}
}
def p1 = new Person()
p1.nameSayer()

def theName = "John"

def sayName = {
	print theName
}
sayName()

theName = "Bill"
sayName()

In fact in groovy we can now call our property and offset the name to a default value of "Fred".
Now I also have a second instance variable.
This time the instance variable holds or contains a closure.
In fact the variable "nameSayer" is actually of type closure itself.
Now the default block of code for this closure "nameSayer" will print name to the console.
So when I create a new instance of the class I referenced the closure which is held in instance variable "nameSayer".
I can evaluate this closure just like a normal method.
Closures keep a refernce to the context in which they've been defined.

Now you can see in the second example that the closure "sayName" has a reference to the variable "theName" which is currently equal to John.
And when we evaluate this closure that's exactly what we see, we see that name "John" printed to the console.
Now if we decide to change the value of the name variable to "Bill" for example what happens when we actually run that closure again?
We can see the actual value being printed to the console was changed to "Bill",is no longer "John".

So as the contents of the variable itself changes the actual result of the closure when evaluate it is different.
So what's going on behind the scenes here?
Well it turns out(判明する) the closures keep a reference to the context object in which they're defined and not a reference to the values.

So the important take home point here is that when the context is actually updated and when the closure runs again,
it will run against the new values actually held in the context.

JavaScript also uses this concept a lot and it's really key in actually understanding how gradle uses groovy as a scripting language too.
By default in groovy this context is also known as the owner object.
This concept of the context with a closure is really key to understanding how gradle or groovy actually work together.

Now with working with gradle and groovy, you'll hear a lot about a delegate object.
While the delegate object is just another groovy term for the context with which the closure actually runs against.

Now here is my class Person I've created a new method called "executeInside" and that takes with a parameter which happens to be a closure.

class Person2 {
    String theName
    Integer theAge
     Person2(theName, theAge) {
        this.theName = theName
        this.theAge = theAge
    }
	def executeInside(Closure c){
		c.delegate = this
		c()
	}
}

def p2 = new Person2("Fred", 35)
// println p2.theName 
p2.executeInside { println theName }


Now the first line of the method you can see I'm referencing the delegate property which is actually a property on the closure.
Now I'm assigning to that or setting that with "this" which is the key word "this" which equates to the instance of Person.
Now once this property has been set, I then run or evaluate the closure by calling "c" where the open and close brackets.
So what does all this actually mean?
Well it means that we can create a new person object and execute an arbitary(任意の) block of code against that object.
And also have access to the instance variables of that object.

Now when you think about it, this is a really powerful concept because we can now actually add arbitrary(任意の) code to a class
without having to change the class and this is really useful to know because this is exactly how gradle works behind the scenes.
And I'll be looking at this concept and how it works throughout this course as it's same fundamental to actually understanding how gradle works behind the scenes.

<<< 14. Introduction the Gradle Object Model  >>>
・６つの重要なgradle APIがある。

①Script<Interface>
　全てのbuild.gradleファイルにはScript<Interface>が実装されており、共通で利用可能なプロパティやメソッドがある。

②Project<Interface>

③Gradle<Interface>

④Settings<Interface>

⑤Task<Interface>
⑥Action<Interface>

※⑤⑥は一緒に仕事する。

<<< 15. Introduction the Gradle Lifecycle >>>

1.Initialization
　→init.gradle + other.gradle
　→settinngs.gradle
2.Configuration
3.Execution
　→build.gradle

<<< 16. The Gradle Initialization Phase >>>

1.Initialization
　→init.gradle + other.gradle
　　・・・ + other.gradle は、拡張子が.gradleであれば
　　　　　C:\Users\sufur\.gradle\init.d　配下にあるものがabc順に、Initialization phaseの中で実行される。
　　　　　other.gradle のどれかでclosure が定義された場合、その他のother.gradleでもそれを利用可能。グローバル変数のように。
　→settinngs.gradle
　　・・・複数プロジェクトの際に必須。プロジェクトが一つのみの場合は任意。

Now these scripts however run before the actual build stats, and there are several good reasons for this.
They allow you to set up various configurations, like to set up enterprise wide configuration
such as where to find customized plugins to set up properties based on the current environment such as a
developer's machine vs a CI server.

They can supply personal information about the user that is required by the build such as database authentication.
They can define specific details such as build listeners and also register build loggers.

Npw later on in the course I'll be looking at using the initialization scripts to help us set up our building (farmer …後で説明するというのだから後で明らかになるでしょう)
before we perform the build itself.

Now the settings.gradle file is more specific and is oriented(方向づけられた、志向の) (towards) multi project projects.
And that's why a gradle determines（決める、定める） which projects to include in the build. 
I'll be looking that in a section of the course about multiple projects.

And the "Configuration phase" relies on the build.gradle file, and the "Execution phase" also.
And you have a build.gradle file for each of those projects.
So if you have a multi project, each project have to have a build.gradle file.
<<< 16. The Gradle Initialization Phase >>>　以後省略。

<<< 17. Lifecycle Phases and the Gradle Object Model >>>

～出だし省略～
I finished the last tutorial by showing an example where I shared a clusure which produces a timestamp,
and then within each of the scripts we printed out to the console the actual date and time when it ran.

A couple of interesting aspects(側面) to how I did this.
The first is that I use the property called timestamp.

Now I'm not going to look at that in this tutorial but what I want to start looking at is the actual object we set that timestamp on.

-------------------------------------------
import java.text.*
gradle.ext.timestamp = {
   def df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'")
   df.setTimeZone(TimeZone.getTimeZone("UTC"))
   return df.format(new Date())
}
println ">>> another.gradle --> This is executed during the initialization phase  - timestamp @ ${gradle.timestamp()}"
-------------------------------------------

I accessed an object called "gradle".
Now the "gradle" object we have access to throughout the entire buid lifecycle and that's why I want to look at in this tutorial.
All the various gradle objects that we have access to at various points within the build lifecycle.

Now generally speaking in most gradle builds you're not going to have as many files as I have in this example.
I just created as many files as I could just to show an example of how gradle evaluates the files in the ordering in which it does (so).

But we're always going to have one file with another gradle build and that's the build.gradle file.
So let's start looking at the build.gradle file, the object model that goes along with that.

So to begin with we know that every projects has a build.gradle file ant that build.gradle file represents(表す、説明する)
a script or a build script.

When we run our build script, gradle actually instantiates an object that implements the Script<Interface>,
and it does this (for the) build script within our build.
So in the last tutorial where I jad five files with a ".gradle" extention, that equates to five build scripts.
So in effect(要するに) you have five objects instantiated that implement the Script<Interface>.
That's one for each build script.

Now we've also seen in past tutorial that we have access to a whole bunch of properties and methods on the build script.
But this isn't the end of the story.

We also have access to another object called the "delegate".
Now the delegate can change depending on which part of the build lifecycle you happen to be in.

Say for example where(we are?) in the actual configuration phase and we're working on our build.gradle file,
well our delegate object there happens to be called Project is called project because it implements the project interface.
And if we go over to the gradle API documentation, we can actually reference the project interface.
And once we reference the documentation we get a really clear idea as to some of the properties and 
methods that are publicly available to us so we can actually used within our builds.

But it's really important to note that the delegate object is different depending on which part of the
gradle build lifecycle you happen to be working in.
And that's one of the reasons I've spent so much time going over this concept because so many people
get cunfused by it (and so many banks get graded that way)

So in the build.gradle file we have access to a script object and that gives us access to properties
such as the logger and the apply method that takes in a closure.
And we also have access to the delegate which is the project object which is an object that implements the project interface.
Now this is only because we're in the configuration phase and we have a different story when we start
looking at the setting.gradle file, is only mandatory(必須の) when we have a build that consists(から成る) of 
many projects and I'll be looking at multi projects build later on of course, but for now I just want to show
that within that lifecycle or that aspect of the lifecycle we still have access to the script object or an 
object that implements the script interface but the delegate object is different, is actually an object that 
implements the settings interface and that gives us a different bunch of properties and methods.
This is mainly to do with separation of concerns(関心の分離).
We're only concerned when we're using their settings.gradle file with multi project builds.
So the actual interface the settings interface is more geared toward(～に適合/調整させた) that.

You'll notice that within the setting object, we can have access to all the projects that make up the build.
In the last tutorial I showed a whole bunch of initialization scripts (so) just made up so you could 
see the order in which they're evaluated by gradle but generally if you want to use the initialization
scripts, you'll use the init.gradle file.

Now thought the other build scripts you have access to a script object that implements the script interface,
and also a delegate object that comes along with it.
But this time the delegate object isn't settings or project, it's an object that implements the gladle interface.

Now this meke total sense when you think about where the initialization scripts get evaluated.
They get evaluated in the initialization phase and at that point gradle doesn't know anything about any project in the build.
So it has access to a higher level object that implements the gradle interface and our initialization scripts have access to 
all the public properties and methods that go along with that interface.

So just a recap(要約) our build script which lives in the build.gradle file uses a script object and also
delegates to an object that implements the project interface and the build script runs in the configuration phase of the build lifecycle.

The settings.gradle script also has a script object or an object that implements the script interface and delegates to an 
object that implements the settings interface and that runs in the initialization phase,
and a init.gradle scripts which also have access to a script object, (a?the?) delegate to an object that implements the gradle interface.

These objects don't live on their own.

The project object also has access through a propertiy to the gradle object.
That's also true for the settings object that also has accsess to the gradle object.

So in the previous example you saw I access to gradle object in the init.gradle file, settings.gradle file,
or on the actual build.gradle file and that is how I was able to set the timestamp closure and use it
almost as global data because I set it as a property on the gradle object itself.
And that's what I'm going to start looking at in the next tutorial, properties and how we can create our own properties 
and set them on a gradle object model  

【build.gradle   】 delegates to → 【Project  Interface】in a Configuration  Phase ーーー￢
                                                                                           ｜
【settings.gradle】 delegates to → 【Settings Interface】in a Initialization Phase ー￢   ｜
                                                                                       ↓  ↓
【init.gradle    】 delegates to → 【Gradle   Interface】in a Initialization Phase　←←←

<<< 18. Lifecycle Phases and the Gradle Object >>>
OK
※dot notation ドット表記

<<< 19. Lifecycle Phases and the Project Object >>>
OK

<<< 20. Gradle Properties >>>
OK

<<< 21. ...more on Gradle Properties >>>

～略～
ExtraPropertiesExtension allow new properties to be added to existing domain objects(*).
This is a really powerful concept.
So pretty much it acts like a map allowing storage of arbitrary key value pairs like the properties file we saw a minute ago.
All domain objects that implement an interface called ExtentionAware intrinsically(内因的に 本質的に) have access to
extended name properties and we do that using the syntax of "ext" as I've done here.

project.ext.sayHello = "Hello!"
logger.info project.sayHello
//	logger.info sayHello // <-- this is also possible

Now here you can see I'm using the extension name on the project object and I've added a property called "sayHello".
And I'm assigning that a string of value "Hello!"
Now where to access that property a little lator on because I actually want to pass the value to the
logger to print it out to the console. So how do I do that?
Well really I just treat it as any other property.

It's only at the time of setting it up that I need to use the extension name of "ext" when I access it.
I can access it just as any other property.
And that's part of the magic of gradle and groovy working together that allows us to do that.

(*)domain objects …Project ObjectやGradle Objectのこと。文脈による。

<<< 22. Tasks and the Gradle Lifecycle ... >>>

～略～
...I've been looking at projects and I'm gonna start shifting the attention now to start looking at tasks
and what tasks are.
Now as we already know every gradle build is made up of one or more projects.
Now what a project represents depends on what it is we're trying to do in gradle for example it might
represent a library or a jar file or even a whole web application.

It doesn't necessarily represent a thing that must be built.
It might represent a thing to be done such as deploying your application to a staging or enven a production environment.
Each project is made up of one or more tasks.
In fact conceptually(概念的に) a project can be seen as a collection of tasks, a task represents an atomic piece of wor
performed by the build.

In previous tutorials I went to some length talking about the gradle lifecycle how we had the
initialization phase, the configuration phase, and the execution phase.

Well the gradle lifecycle applies for a match to tasks as well but really only in the configuration and execution phases.

So what do we do in the configuration phase?
Well in the configuration phase we can actually create the task or define a task and we can also configure
the task that is we can add code through closures and properties to that particular task.
Now in the execution phase this is where we actually execute the tasks and the task performs its atomic actions for the build.

・Configuration Phase → Create/Configure Tasks 
・Execution Phase → Execute Tasks

～略～

Project can contain a collection of zero or many tasks.
But what about tasks?
What makes up a task, a task can be mae up of zero or many actions.
So in a similar way that a project is made up of a collection of tasks, a task itself can be made up of a collection of actions.

The task represents a single atomic piece of work for a build such as compiling classes or generating JavaDoc.
So each task belongs to a project.

Now the collection of tasks are held in the project by the task container and it has a whole bunch of helper methods for
creating and looking up instances of tasks.
Each task has a name which can be used to refer to the task within the project that owns it.
In a similar way a task is made up of a sequence of action objects and when a task is executed,
each of these action objects is executed in turn.

There are two really convenient methods on the task interface, "doFirst()" and "doLast()".
There are two versions of these methods.
The first version takes the action interface as a parameter and the second accepts a closure.

Now because we're using groovy we're going to be using the clusure version of the method doFirst and doLast.
Now by using the closure version, when we execute our task and our action, the task gets passed into the closure as a parameter.
So within the closure itself we also have access to the task that the clusure is runnig in.
The doFirst and doLast methods also return the task and this is ideal(理想的なもの) because we can then chain method call
so we can actually call doFirst and doLast again just using the dot notation rather than having to split it outline after line.

So this is ideal if you've got lots of actions to add to our task, it's worth noting that all this is still
happening within the configuration phase of the gradle lifecycle.

We have not yet stepped across into the execution phase so let's head over to eclipse and see how it
can implement a task by creating some task and creating some actions using the doFirst and doLast methods
and chaining those method calls and then let's actually start looking at executing or using the execution phase of the gradle lifecycle.

<<< 23. Our 1st Gradle Task ... >>>
～略～
... How do I create a task?
Well there are a number of ways but probably the easiest way is to use the keyword "task".
I'm defining a new task and I'm going to give it a name "hi".

---
logger.info ">>> build.gradle --> This is executed during the configuration phase  - timestamp @ ${gradle.timestamp()}"
task hi
---

～略～
If I run this now you'll see the task actually gets executed.
And it' actually getting executed in the execution phase of the gradle lifecycle
so when we define our task, so here we got "task space hi".
This occurs within the configuration phase of the gradle lifecycle.
And when we actually run that, this is the actual execution phase and we've not seen that before.
That's the first time we've executen the part of the gradle lifecycle.

Now this may sound like a small point but it's a really important concept to understand.
So we configure our task in the configuration phase of the gradle lifecycle.
So that's the place where we add our code, in other words our closures and defining our properties.
But when we actually want that code to run and to perform the task, we've told it to perform,
then that gets done in the execution phase.

～略～
So how can we add some code to out task to make actually do something?
Well as we saw in the last tutorial we use the doFirst and doLast methods and we set the definition
of those (up) in a configuration phase and if we go over to the gradle JavaDocs we actually look at
the API and see the definition for doFirst and doLast.
doFirst accepts an action which happens to be a closure
and the same goes also for the doLast.

So we can call the actual doFirst and doLast method passing in a closure that contains the code we
actually gradle to perform.

Now with the power of groovy is our programming language in gradle,
we can now access our newly created task as a property and it's a property on the project object,
and we can access it using the dot notation.
So we can say "project.hi".

---
logger.info ">>> build.gradle --> This is executed during the configuration phase  - timestamp @ ${gradle.timestamp()}"
task hi
project.hi
---
This may seem a little strange if you're coming from a Java background but in the groovy world this is a natural thing to do.
And it's to do with the way groovy deals with maps and properties.

So once we have access to our task we can configure it to use the (doFirst and the doLast) method.
So we just again use the dot notation followed by the method name doLast, and we passed the doLast method of closure.
---
logger.info ">>> build.gradle --> This is executed during the configuration phase  - timestamp @ ${gradle.timestamp()}"
task hi
project.hi.doLast{
	logger.info "Hi!"
}
---
And in this closure I'm just going to write out "Hi!" to the logger.
So this time when we run our build you can see we're actually writing out the word "Hi!" to the logger.
This is actually happening during the execution phase of the gradle lifecycle.
So setting up doLast is in the configuration phase, but the actual task of executing the doLast method 
occurs the execution phase of the lifecycle.

We can also configure our task while we create it.
What I mean by that, (well) we can actually pass in our configuration closure at the same time as using the task keyword.
---
defaultTasks "hello"
logger.info ">>> build.gradle --> This is executed during the configuration phase  - timestamp @ ${gradle.timestamp()}"
task hi
project.hi.doLast{
	logger.info "Hi!"
}
task hello{
	description = "Log the name of the Task"
	group = "Welcome"
	doLast{
		logger.info "My name is: $name and thsi is my 1st defined action."
	}
	
}
logger.info hello.description
logger.info hello.group


---
So for example here we've got the hello task being created.
And then we just pass in a closure with the curly braces.
So what sort of things can we include in our configuration closure?
(Well) remenber in this closure, we also have access to the task instance itself.
So we can access various properties.
So I'm gonna set the description property and also the group property.
Now description is just some meaningful description of what the task is all about.
And the group, well basically we can assign our task to a group of other tasks.
So in this case I'm going to assign this task to the "Welcome" group.
Now once we've done this, we can actually access our properties on the hello task and we just do that
using the dotnotation so we access the hello task as we did before.
And then we just do dot description and we can do exactly the same for the group.
And as you can see I'm just using the logger to print those out to the console.

Now if you remember I mentioned that when we actually writing the doFirst and doLast methods,
they actually happen within the configuration phase of the gradle lifecycle and being configuration
that means we can actually put them into this configuration closure as well.

So here I'm setting the actual properties for description and group where I can also add our method calls
to doFirst and doLast.
So basically within the curly braces of the closure I can just write the code to the doLast method,
and also passing the closure to that.

Now one thing I notice is that I'm not using a dot notation here because basically the actual delegate object
behind the scenes for this configuration closure is the task object.

So when we're actually accessing properties or methods, it's implied we're actually accessing those property
and methods on the delegate object.
And in this instance the delegate object is equal to the hello task object itself and you can see
I'm using this even in the output string in the doLast where I'm accessing the name through interpolation.

I talked about the delegate object and how powerful this technique is in the groovy part of the cource.
And this is just an example of it being used.

So let's go ahead and also create a call to doFirst method and I'm just gonna output another string.
So when we execute this task what order you think the output will be here?

As the name implies it says do this first.
So that method always gets invoked first.

～略～
...add a default task in our build.gradle file and what we'll do is we'll include the hello task.
So we don't need to actually configure our run configuration.
We can actually just modify the build.gradle file.

～略～
You also notice in the gradle executions tab on the buildship plugin.(on eclipse) actually shows the tasks that have run.
And you can see with code on hello.
We also can see the actual actions that have been performed.
Just notice the order here, you can see the doFirst action was done first followed by the doLast.

<<< 24. Configuring Tasks >>>
～略～
Every time we called doFirst, the closure we pass in is always guranteed to be the first closure that actually gets executed.
And when we called doLast, that closure is guranteed to be the last action to be executed in the tasks actions list.
-------------------
task hello{
	doFirst{
		logger.info "My name is: $name and thsi is my 1st defined action." //3
	}
	doLast{
		logger.info "My name is: $name and thsi is my 2nd defined action." //4
	}
}
hello.doFirst{
	logger.info "My name is: $name and thsi is my ?th defined action." // 2
}
hello.doLast{
	logger.info "My name is: $name and thsi is my 3rd defined action." // 5
}
hello.doLast{
	logger.info "My name is: $name and thsi is my 4th defined action." // 6
}
hello.doFirst{
	logger.info "My name is: $name and thsi is my 5th defined action." // 1
}

My name is: hello and thsi is my 5th defined action.
My name is: hello and thsi is my ?th defined action.
My name is: hello and thsi is my 1st defined action.
My name is: hello and thsi is my 2nd defined action.
My name is: hello and thsi is my 3rd defined action.
My name is: hello and thsi is my 4th defined action.
-------------------

Something to take note as well is that the return type of the doFirst and doLast method is that of "Task" (object).
So each time we call these methods they actually return the "Task" that the method is being invoked on.

So how does that work?
Well let's start with a new example.
It's pretty much exact the same as the original but this time what I'm going to do is each time I call
doFirst and doLast method, I'm actually be going to chain another doLast or doFirst method onto using the dot notation.

---------------------
task hello2{
}
hello2.doFirst{
	logger.info "My name is: $name and thsi is my 1st defined action."
}.doLast{
	logger.info "My name is: $name and thsi is my 2nd defined action."
}.doFirst{
	logger.info "My name is: $name and thsi is my ?th defined action."
}.doLast{
	logger.info "My name is: $name and thsi is my 3rd defined action."
}.doLast{
	logger.info "My name is: $name and thsi is my 4th defined action."
}.doFirst{
	logger.info "My name is: $name and thsi is my 5th defined action."
}
My name is: hello2 and thsi is my 5th defined action.
My name is: hello2 and thsi is my ?th defined action.
My name is: hello2 and thsi is my 1st defined action.
My name is: hello2 and thsi is my 2nd defined action.
My name is: hello2 and thsi is my 3rd defined action.
My name is: hello2 and thsi is my 4th defined action.
------------------------
I can add as many actions as I wish so hello2 is now a rewritten version of the hello task and you'll
see I'm chaining all that doFirst and doLast methods again.
You'll notice the outputs identical because basically they're in exactly the same thing.
This can help make our code more consise and readable.
And it's also a feature of the DSL or domain specific language, that's gradle procvides us.


<<< 25. Introduction to 'dependsOn' >>>
dependsOn キーワードを使いtaskの順番を定義することが可能。
異なる場所(task)で同じtaskをdependsOnで指定すると、１度しか呼ばれない。２回目の方は呼ばれない。


<<< 26. Filtering tasks with 'dependsOn' >>>
